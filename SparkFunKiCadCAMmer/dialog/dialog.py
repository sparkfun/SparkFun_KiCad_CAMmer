"""Subclass of dialog_text_base, which is generated by wxFormBuilder."""
from logging import exception
import os
import wx
import json
import sys

from . import dialog_text_base

_APP_NAME = "SparkFun KiCad CAMmer"

# sub folder for our resource files
_RESOURCE_DIRECTORY = os.path.join("..", "resource")

#https://stackoverflow.com/a/50914550
def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base_path, _RESOURCE_DIRECTORY, relative_path)

def get_version(rel_path: str) -> str:
    try: 
        with open(resource_path(rel_path), encoding='utf-8') as fp:
            for line in fp.read().splitlines():
                if line.startswith("__version__"):
                    delim = '"' if '"' in line else "'"
                    return line.split(delim)[1]
            raise RuntimeError("Unable to find version string.")
    except:
        raise RuntimeError("Unable to find _version.py.")

_APP_VERSION = get_version("_version.py")

class Dialog(dialog_text_base.DIALOG_TEXT_BASE):

    empty_config = {'Layers':{},'Edges':{}}
    # Default config in JSON style
    config_defaults = {
        'Layers':
        {
            'F.Cu': 'true',
            'In1.Cu': 'true',
            'In2.Cu': 'true',
            'In3.Cu': 'true',
            'In4.Cu': 'true',
            'B.Cu': 'true',
            'F.Paste': 'true',
            'B.Paste': 'true',
            'F.Silkscreen': 'true',
            'B.Silkscreen': 'true',
            'F.Mask': 'true',
            'B.Mask': 'true',
            'Edge.Cuts': 'false',
            'User.Comments': 'false'
        },
        'Edges':
        {
            'F.Cu': 'false',
            'In1.Cu': 'false',
            'In2.Cu': 'false',
            'In3.Cu': 'false',
            'In4.Cu': 'false',
            'B.Cu': 'false',
            'F.Paste': 'false',
            'B.Paste': 'false',
            'F.Silkscreen': 'false',
            'B.Silkscreen': 'false',
            'F.Mask': 'false',
            'B.Mask': 'false',
            'Edge.Cuts': 'true',
            'User.Comments': 'true'
        }
    }

    def __init__(self, parent, config, layertable, cammer, func):
        dialog_text_base.DIALOG_TEXT_BASE.__init__(self, parent)
        
        # hack for some gtk themes that incorrectly calculate best size
        #best_size = self.BestSize
        #best_size.IncBy(dx=0, dy=30)
        #self.SetClientSize(best_size)

        self.config_file = config

        self.layertable = layertable

        self.cammer = cammer

        self.func = func

        self.error = None

        self.SetTitle(_APP_NAME + " - " + _APP_VERSION)


        # Load up last sessions config
        self.config = self.empty_config
        self.loadConfig()

        # Delete any config items not present in layertable - just in case layertable has changed
        for key in self.config.keys():
            deleteThese = []
            for layer in self.config[key].keys():
                if layer not in layertable.keys():
                    deleteThese.append(layer) # Avoids "dictionary changed size during iteration"
            for d in deleteThese:
                self.config[key].pop(d, None)

        # Copy the configuration defaults
        # Delete any layers present in the config from file - so we don't overwrite them
        # Also delete those which are not in layertable
        # Then update (copy) them into the config
        defaults = self.config_defaults
        for key in defaults.keys():
            deleteThese = []
            for layer in defaults[key].keys():
                hasKey = False
                try:
                    hasKey = layer in self.config[key].keys()
                except:
                    pass
                if (layer not in layertable.keys()) or hasKey:
                    deleteThese.append(layer)
            for d in deleteThese:
                defaults[key].pop(d, None)
        for key in defaults.keys():
            self.config[key].update(defaults[key])

        # Add any extra layers which are present in layertable - default these to disabled
        for key in self.config.keys():
            addThese = []
            for layer in layertable.keys():
                if layer not in self.config[key].keys():
                    addThese.append(layer)
            for a in addThese:
                d = {a: 'false'} # JSON style
                self.config[key].update(d)

        # Load the configuration into the Dialog grids
        self.LoadSettings()

        # Autosize now grid is populated
        self.LayersGrid.AutoSizeColumns()
        self.EdgesGrid.AutoSizeColumns()

    def loadConfig(self):
        ''' Load the last sessions configuration from json file '''
        try:
            with open(self.config_file, 'r') as cf:
                json_params = json.load(cf)
            self.config.update(json_params)
        except Exception as e:
            # Don't throw exception if we can't load previous config
            pass

    def saveConfig(self):
        ''' Read the configuration from the Dialog grids and save to file '''
        try:
            with open(self.config_file, 'w') as cf:
                json.dump(self.CurrentSettings(), cf, indent=2)
        except Exception as e:
            # Don't throw exception if we can't save config
            pass
            
    def LoadSettings(self):
        ''' Load the settings from self.config into the Dialog grids '''

        # Delete any existing rows in LayersGrid
        if self.LayersGrid.NumberRows:
            self.LayersGrid.DeleteRows(0, self.LayersGrid.NumberRows)
        # Append empty rows based on layertable
        self.LayersGrid.AppendRows(len(self.layertable))
        # Initialize them
        row = 0
        for layer, enabled in self.config['Layers'].items():
            e = "1" if enabled == 'true' else "0" # JSON style
            self.LayersGrid.SetCellValue(row, 0, e)
            self.LayersGrid.SetCellRenderer(row, 0, wx.grid.GridCellBoolRenderer())
            self.LayersGrid.SetCellValue(row, 1, layer)
            self.LayersGrid.SetReadOnly(row, 1)
            row += 1
            
        # Delete any existing rows in EdgesGrid
        if self.EdgesGrid.NumberRows:
            self.EdgesGrid.DeleteRows(0, self.EdgesGrid.NumberRows)
        # Append empty rows based on layertable
        self.EdgesGrid.AppendRows(len(self.layertable))
        # Initialize them
        row = 0
        for layer, enabled in self.config['Edges'].items():
            e = "1" if enabled == 'true' else "0" # JSON style
            self.EdgesGrid.SetCellValue(row, 0, e)
            self.EdgesGrid.SetCellRenderer(row, 0, wx.grid.GridCellBoolRenderer())
            self.EdgesGrid.SetCellValue(row, 1, layer)
            self.EdgesGrid.SetReadOnly(row, 1)
            row += 1

    def CurrentSettings(self):
        params = self.empty_config

        for row in range(self.LayersGrid.GetNumberRows()):
            enabled = 'true' if (self.LayersGrid.GetCellValue(row, 0) == "1") else 'false' # JSON style
            layer = self.LayersGrid.GetCellValue(row, 1)
            d = {layer: enabled}
            params['Layers'].update(d)

        for row in range(self.EdgesGrid.GetNumberRows()):
            enabled = 'true' if (self.EdgesGrid.GetCellValue(row, 0) == "1") else 'false' # JSON style
            layer = self.EdgesGrid.GetCellValue(row, 1)
            d = {layer: enabled}
            params['Edges'].update(d)

        return params

    def OnRunCAMmerClick(self, e):
        self.saveConfig()
        self.func(self, self.cammer)

    def OnCancelClick(self, e):
        self.EndModal(wx.ID_CANCEL)     
